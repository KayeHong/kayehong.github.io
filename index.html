<!--
import androidx.compose.animation.core.Animatable
import androidx.compose.animation.core.tween
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Favorite
import androidx.compose.material.icons.filled.Home
import androidx.compose.material.icons.filled.Settings
import androidx.compose.material.icons.filled.Star
import androidx.compose.material3.Icon
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch
import kotlin.math.roundToInt

@Composable
fun LauncherAnimationDemo() {
    val icons = listOf(
        Icons.Default.Home, Icons.Default.Settings, Icons.Default.Favorite,
        Icons.Default.Star, Icons.Default.Home, Icons.Default.Settings,
        Icons.Default.Favorite, Icons.Default.Star, Icons.Default.Home,
        Icons.Default.Settings, Icons.Default.Favorite, Icons.Default.Star,
        Icons.Default.Home, Icons.Default.Settings, Icons.Default.Favorite,
        Icons.Default.Star
    )
    val iconState = remember { icons.toMutableStateList() }
    val iconOffsets = remember { icons.map { Animatable(Offset.Zero) }.toMutableStateList() }

    Box(modifier = Modifier.fillMaxSize()) {
        Column {
            iconState.chunked(8).forEachIndexed { pageIndex, pageIcons ->
                Column {
                    pageIcons.chunked(4).forEachIndexed { rowIndex, rowIcons ->
                        Row(
                            horizontalArrangement = Arrangement.Center,
                            verticalAlignment = Alignment.CenterVertically,
                            modifier = Modifier.fillMaxWidth()
                        ) {
                            rowIcons.forEachIndexed { colIndex, icon ->
                                val iconIndex = pageIndex * 8 + rowIndex * 4 + colIndex
                                val offset = iconOffsets[iconIndex]

                                DraggableIcon(
                                    icon = icon,
                                    offset = offset.value,
                                    onDrag = { dragAmount ->
                                        val newOffset = offset.value + dragAmount
                                        if (newOffset.x >= 0f && newOffset.y >= 0f) {
                                            offset.snapTo(newOffset)
                                        }
                                    },
                                    onDragEnd = { finalOffset ->
                                        val targetIndex = calculateTargetIndex(finalOffset, iconState.size)
                                        if (targetIndex != iconIndex) {
                                            swapIcons(iconState, iconOffsets, iconIndex, targetIndex)
                                        } else {
                                            offset.animateTo(Offset.Zero, tween(300))
                                        }
                                    }
                                )
                            }
                        }
                    }
                }
            }
        }
    }
}

@Composable
fun DraggableIcon(
    modifier: Modifier = Modifier,
    icon: ImageVector,
    offset: Offset,
    onDrag: (Offset) -> Unit,
    onDragEnd: (Offset) -> Unit
) {
    val coroutineScope = rememberCoroutineScope()

    Box(
        modifier = modifier
            .offset { IntOffset(offset.x.roundToInt(), offset.y.roundToInt()) }
            .pointerInput(Unit) {
                detectDragGestures(
                    onDrag = { change, dragAmount ->
                        onDrag(Offset(dragAmount.x, dragAmount.y))
                    },
                    onDragEnd = {
                        onDragEnd(offset)
                    }
                )
            }
            .size(48.dp)
            .background(Color.Gray, CircleShape)
    ) {
        Icon(
            imageVector = icon,
            contentDescription = null,
            modifier = Modifier
                .align(Alignment.Center)
                .size(24.dp),
            tint = Color.White
        )
    }
}

fun calculateTargetIndex(offset: Offset, itemCount: Int): Int {
    val position = (offset.x / 100).toInt() + (offset.y / 100).toInt() * 4
    return position.coerceIn(0, itemCount - 1)
}

fun swapIcons(
    icons: MutableList<ImageVector>,
    offsets: MutableList<Animatable<Offset, Offset>>,
    fromIndex: Int,
    toIndex: Int
) {
    icons[fromIndex] = icons[toIndex].also { icons[toIndex] = icons[fromIndex] }
    offsets[fromIndex] = offsets[toIndex].also { offsets[toIndex] = offsets[fromIndex] }
}


-->
