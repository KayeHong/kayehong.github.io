<!--
import androidx.compose.animation.core.Animatable
import androidx.compose.animation.core.tween
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Favorite
import androidx.compose.material.icons.filled.Home
import androidx.compose.material.icons.filled.Settings
import androidx.compose.material.icons.filled.Star
import androidx.compose.material3.Icon
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch
import kotlin.math.roundToInt

@Composable
fun DraggableIconDemo() {
    val icons = listOf(
        Icons.Default.Home, Icons.Default.Settings, Icons.Default.Favorite,
        Icons.Default.Star
    )
    val iconOffsets = remember { icons.map { Pair(Animatable(0f), Animatable(0f)) }.toMutableStateList() }
    var highlightedIndex by remember { mutableStateOf(-1) }
    val draggableOffsetX = remember { Animatable(0f) }
    val draggableOffsetY = remember { Animatable(0f) }
    val coroutineScope = rememberCoroutineScope()

    Column(
        modifier = Modifier.fillMaxSize(),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Row(
            horizontalArrangement = Arrangement.spacedBy(16.dp),
            verticalAlignment = Alignment.CenterVertically,
        ) {
            icons.forEachIndexed { index, icon ->
                val offsetX = iconOffsets[index].first.value
                val offsetY = iconOffsets[index].second.value
                Box(
                    modifier = Modifier
                        .offset { IntOffset(offsetX.roundToInt(), offsetY.roundToInt()) }
                        .size(48.dp)
                        .background(if (index == highlightedIndex) Color.Red else Color.Gray, CircleShape)
                ) {
                    Icon(
                        imageVector = icon,
                        contentDescription = null,
                        modifier = Modifier.align(Alignment.Center).size(24.dp),
                        tint = Color.White
                    )
                }
            }
        }

        Spacer(modifier = Modifier.height(48.dp))

        DraggableIcon(
            icon = Icons.Default.Star,
            offsetX = draggableOffsetX.value,
            offsetY = draggableOffsetY.value,
            onDrag = { dragAmount ->
                coroutineScope.launch {
                    draggableOffsetX.snapTo(draggableOffsetX.value + dragAmount.x)
                    draggableOffsetY.snapTo(draggableOffsetY.value + dragAmount.y)

                    val overlapIndex = calculateOverlapIndex(
                        Offset(draggableOffsetX.value, draggableOffsetY.value),
                        icons.size
                    )
                    highlightedIndex = overlapIndex
                }
            },
            onDragEnd = {
                coroutineScope.launch {
                    draggableOffsetX.animateTo(0f, tween(300))
                    draggableOffsetY.animateTo(0f, tween(300))
                    highlightedIndex = -1
                }
            }
        )
    }
}

@Composable
fun DraggableIcon(
    modifier: Modifier = Modifier,
    icon: ImageVector,
    offsetX: Float,
    offsetY: Float,
    onDrag: (Offset) -> Unit,
    onDragEnd: () -> Unit
) {
    Box(
        modifier = Modifier
            .offset { IntOffset(offsetX.roundToInt(), offsetY.roundToInt()) }
            .pointerInput(Unit) {
                detectDragGestures(
                    onDrag = { change, dragAmount ->
                        onDrag(Offset(dragAmount.x, dragAmount.y))
                    },
                    onDragEnd = {
                        onDragEnd()
                    }
                )
            }
            .size(48.dp)
            .background(Color.Blue, CircleShape)
    ) {
        Icon(
            imageVector = icon,
            contentDescription = null,
            modifier = Modifier.align(Alignment.Center).size(24.dp),
            tint = Color.White
        )
    }
}

fun calculateOverlapIndex(dragOffset: Offset, itemCount: Int): Int {
    val itemSize = 48.dp.toPx()
    val spacing = 16.dp.toPx()
    val itemWidth = itemSize + spacing
    val itemHeight = itemSize + spacing

    for (i in 0 until itemCount) {
        val itemStartX = i * itemWidth
        val itemEndX = itemStartX + itemSize
        val itemStartY = 0f
        val itemEndY = itemSize

        if (dragOffset.x in itemStartX..itemEndX && dragOffset.y in itemStartY..itemEndY) {
            return i
        }
    }

    return -1
}

@Composable
fun Dp.toPx(): Float {
    return with(LocalDensity.current) { this@toPx.toPx() }
}


-->
