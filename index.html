<!--
import androidx.compose.animation.core.Animatable
import androidx.compose.animation.core.tween
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.Button
import androidx.compose.material.Text
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Favorite
import androidx.compose.material.icons.filled.Home
import androidx.compose.material.icons.filled.Settings
import androidx.compose.material.icons.filled.Star
import androidx.compose.material3.Icon
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch
import kotlin.math.roundToInt

@Composable
fun IconRevealDemo() {
    val icons = listOf(
        Icons.Default.Home, Icons.Default.Settings, Icons.Default.Favorite, Icons.Default.Star
    )
    var condition by remember { mutableStateOf(false) }
    val secondIconSize = remember { Animatable(0f) }
    val secondIconAlpha = remember { Animatable(0f) }
    val draggableOffsetX = remember { Animatable(0f) }
    val draggableOffsetY = remember { Animatable(0f) }
    val coroutineScope = rememberCoroutineScope()
    val iconSize = 48.dp
    val iconSpacing = 16.dp

    LaunchedEffect(condition) {
        if (condition) {
            coroutineScope.launch {
                secondIconSize.animateTo(48f, tween(500))
                secondIconAlpha.animateTo(1f, tween(500))
            }
        } else {
            coroutineScope.launch {
                secondIconSize.animateTo(0f, tween(500))
                secondIconAlpha.animateTo(0f, tween(500))
            }
        }
    }

    Column(
        modifier = Modifier.fillMaxSize(),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Row(
            horizontalArrangement = Arrangement.spacedBy(iconSpacing),
            verticalAlignment = Alignment.CenterVertically,
        ) {
            icons.forEachIndexed { index, icon ->
                val size = if (index == 1) secondIconSize.value.dp else 48.dp
                val alpha = if (index == 1) secondIconAlpha.value else 1f
                Box(
                    modifier = Modifier
                        .size(size)
                        .alpha(alpha)
                        .background(Color.Gray, CircleShape)
                ) {
                    Icon(
                        imageVector = icon,
                        contentDescription = null,
                        modifier = Modifier.align(Alignment.Center).size(24.dp),
                        tint = Color.White
                    )
                }
            }
        }

        Spacer(modifier = Modifier.height(48.dp))

        DraggableIcon(
            icon = Icons.Default.Star,
            offsetX = draggableOffsetX.value,
            offsetY = draggableOffsetY.value,
            onDrag = { dragAmount ->
                coroutineScope.launch {
                    draggableOffsetX.snapTo(draggableOffsetX.value + dragAmount.x)
                    draggableOffsetY.snapTo(draggableOffsetY.value + dragAmount.y)
                }
            },
            onDragEnd = {
                coroutineScope.launch {
                    val isInside = isInsideIconRow(
                        Offset(draggableOffsetX.value, draggableOffsetY.value),
                        iconSize,
                        iconSpacing,
                        icons.size
                    )
                    if (isInside) {
                        condition = true
                        draggableOffsetX.animateTo((iconSize.toPx() + iconSpacing.toPx()), tween(500))
                        draggableOffsetY.animateTo(0f, tween(500))
                    } else {
                        draggableOffsetX.animateTo(0f, tween(500))
                        draggableOffsetY.animateTo(0f, tween(500))
                        condition = false
                    }
                }
            }
        )
    }
}

@Composable
fun DraggableIcon(
    modifier: Modifier = Modifier,
    icon: ImageVector,
    offsetX: Float,
    offsetY: Float,
    onDrag: (Offset) -> Unit,
    onDragEnd: () -> Unit
) {
    Box(
        modifier = Modifier
            .offset { IntOffset(offsetX.roundToInt(), offsetY.roundToInt()) }
            .pointerInput(Unit) {
                detectDragGestures(
                    onDrag = { change, dragAmount ->
                        onDrag(Offset(dragAmount.x, dragAmount.y))
                    },
                    onDragEnd = {
                        onDragEnd()
                    }
                )
            }
            .size(48.dp)
            .background(Color.Blue, CircleShape)
    ) {
        Icon(
            imageVector = icon,
            contentDescription = null,
            modifier = Modifier.align(Alignment.Center).size(24.dp),
            tint = Color.White
        )
    }
}

fun isInsideIconRow(dragOffset: Offset, iconSize: Dp, iconSpacing: Dp, iconCount: Int): Boolean {
    val itemWidth = iconSize.toPx() + iconSpacing.toPx()
    val totalWidth = itemWidth * iconCount

    val isInsideX = dragOffset.x in 0f..totalWidth
    val isInsideY = dragOffset.y in 0f..iconSize.toPx()

    return isInsideX && isInsideY
}

@Composable
fun Dp.toPx(): Float {
    return with(LocalDensity.current) { this@toPx.toPx() }
}

-->
