<!--
import androidx.compose.animation.core.Animatable
import androidx.compose.animation.core.tween
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Favorite
import androidx.compose.material.icons.filled.Home
import androidx.compose.material.icons.filled.Settings
import androidx.compose.material.icons.filled.Star
import androidx.compose.material3.Icon
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch
import kotlin.math.roundToInt

@Composable
fun DraggableIconDemo() {
    val icons = listOf(
        Icons.Default.Home, Icons.Default.Settings, Icons.Default.Favorite, Icons.Default.Star
    )
    var draggingIconIndex by remember { mutableStateOf(-1) }
    val iconOffsets = remember { icons.map { Pair(Animatable(0f), Animatable(0f)) }.toMutableStateList() }
    val draggableOffsetX = remember { Animatable(0f) }
    val draggableOffsetY = remember { Animatable(0f) }
    val coroutineScope = rememberCoroutineScope()
    val iconSize = 48.dp
    val iconSpacing = 16.dp

    Column(
        modifier = Modifier.fillMaxSize(),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Row(
            horizontalArrangement = Arrangement.spacedBy(iconSpacing),
            verticalAlignment = Alignment.CenterVertically,
        ) {
            icons.forEachIndexed { index, icon ->
                Box(
                    modifier = Modifier
                        .size(iconSize)
                        .background(Color.Gray, CircleShape)
                ) {
                    Icon(
                        imageVector = icon,
                        contentDescription = null,
                        modifier = Modifier.align(Alignment.Center).size(24.dp),
                        tint = Color.White
                    )
                }
                if (index < icons.size - 1) {
                    Spacer(
                        modifier = Modifier
                            .width(if (index == draggingIconIndex) iconSize else 0.dp)
                            .background(Color.Transparent)
                    )
                }
            }
        }

        Spacer(modifier = Modifier.height(48.dp))

        DraggableIcon(
            icon = Icons.Default.Star,
            offsetX = draggableOffsetX.value,
            offsetY = draggableOffsetY.value,
            onDrag = { dragAmount ->
                coroutineScope.launch {
                    draggableOffsetX.snapTo(draggableOffsetX.value + dragAmount.x)
                    draggableOffsetY.snapTo(draggableOffsetY.value + dragAmount.y)
                    val overlapIndex = calculateOverlapIndex(
                        Offset(draggableOffsetX.value, draggableOffsetY.value),
                        iconSize,
                        iconSpacing,
                        icons.size
                    )
                    draggingIconIndex = overlapIndex
                }
            },
            onDragEnd = {
                coroutineScope.launch {
                    if (draggingIconIndex != -1) {
                        draggableOffsetX.animateTo((draggingIconIndex * (iconSize.toPx() + iconSpacing.toPx())), tween(500))
                        draggableOffsetY.animateTo(0f, tween(500))
                        draggingIconIndex = -1
                    } else {
                        draggableOffsetX.animateTo(0f, tween(500))
                        draggableOffsetY.animateTo(0f, tween(500))
                    }
                }
            }
        )
    }
}

@Composable
fun DraggableIcon(
    modifier: Modifier = Modifier,
    icon: ImageVector,
    offsetX: Float,
    offsetY: Float,
    onDrag: (Offset) -> Unit,
    onDragEnd: () -> Unit
) {
    Box(
        modifier = Modifier
            .offset { IntOffset(offsetX.roundToInt(), offsetY.roundToInt()) }
            .pointerInput(Unit) {
                detectDragGestures(
                    onDrag = { change, dragAmount ->
                        onDrag(Offset(dragAmount.x, dragAmount.y))
                    },
                    onDragEnd = {
                        onDragEnd()
                    }
                )
            }
            .size(48.dp)
            .background(Color.Blue, CircleShape)
    ) {
        Icon(
            imageVector = icon,
            contentDescription = null,
            modifier = Modifier.align(Alignment.Center).size(24.dp),
            tint = Color.White
        )
    }
}

fun calculateOverlapIndex(dragOffset: Offset, iconSize: Dp, iconSpacing: Dp, iconCount: Int): Int {
    val itemWidth = iconSize.toPx() + iconSpacing.toPx()
    val totalWidth = itemWidth * iconCount - iconSpacing.toPx()

    val isInsideX = dragOffset.x in 0f..totalWidth
    val isInsideY = dragOffset.y in 0f..iconSize.toPx()

    return if (isInsideX && isInsideY) {
        val index = (dragOffset.x / itemWidth).toInt()
        index.coerceIn(0, iconCount - 1)
    } else {
        -1
    }
}

@Composable
fun Dp.toPx(): Float {
    return with(LocalDensity.current) { this@toPx.toPx() }
}

-->
