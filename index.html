<!--
import jdepend.framework.JavaClass
import jdepend.framework.JavaPackage

class CustomJavaClass(name: String) : JavaClass(name) {
    // 클래스 간의 의존성을 추적할 리스트
    private val customEfferents = mutableSetOf<JavaClass>()

    // 의존성 추가
    fun addCustomEfferent(efferentClass: JavaClass) {
        customEfferents.add(efferentClass)
    }

    // 의존성 목록 반환
    fun getCustomEfferents(): Set<JavaClass> = customEfferents
}

class CustomJavaPackage(name: String) : JavaPackage(name) {
    private val customClasses = mutableSetOf<CustomJavaClass>()

    // 패키지 내 클래스 추가
    fun addCustomClass(javaClass: CustomJavaClass) {
        customClasses.add(javaClass)
    }

    // 패키지 내 클래스 반환
    fun getCustomClasses(): Set<CustomJavaClass> = customClasses
}




import java.io.File

fun generateClassDependencyGraph() {
    // JDepend 확장 객체 사용
    val customPackages = mutableMapOf<String, CustomJavaPackage>()

    // 클래스 관계 수집 (예: 패키지에 클래스와 의존성 추가)
    val mainPackage = CustomJavaPackage("com.example.main")
    val mainClass = CustomJavaClass("com.example.main.MainClass")
    val helperClass = CustomJavaClass("com.example.helper.HelperClass")

    mainClass.addCustomEfferent(helperClass)  // MainClass가 HelperClass를 의존함
    mainPackage.addCustomClass(mainClass)
    customPackages["com.example.main"] = mainPackage

    // DOT 파일 생성
    val dotFile = File("build/reports/class_dependency_graph.dot")
    dotFile.bufferedWriter().use { writer ->
        writer.write("digraph G {\n")
        writer.write("node [shape=box];\n")  // 클래스 노드를 사각형으로 설정

        // 패키지 및 클래스 간 의존성 그리기
        customPackages.forEach { (packageName, customPackage) ->
            customPackage.getCustomClasses().forEach { javaClass ->
                javaClass.getCustomEfferents().forEach { efferent ->
                    writer.write("\"${javaClass.name}\" -> \"${efferent.name}\";\n")
                }
            }
        }

        writer.write("}\n")
    }

    println("DOT file saved to: ${dotFile.absolutePath}")
}

--!>
