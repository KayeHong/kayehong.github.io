<!--
import androidx.compose.animation.core.Animatable
import androidx.compose.animation.core.tween
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Favorite
import androidx.compose.material.icons.filled.Home
import androidx.compose.material.icons.filled.Settings
import androidx.compose.material.icons.filled.Star
import androidx.compose.material3.Icon
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch
import kotlin.math.roundToInt

@Composable
fun DraggableIconDemo() {
    val icons = listOf(
        Icons.Default.Home, Icons.Default.Settings, Icons.Default.Favorite,
        Icons.Default.Star
    )
    val iconOffsets = remember { icons.map { Pair(Animatable(0f), Animatable(0f)) }.toMutableStateList() }
    var highlightedIndex by remember { mutableStateOf(-1) }
    val draggableOffsetX = remember { Animatable(0f) }
    val draggableOffsetY = remember { Animatable(0f) }
    val coroutineScope = rememberCoroutineScope()

    Column(
        modifier = Modifier.fillMaxSize(),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Row(
            horizontalArrangement = Arrangement.spacedBy(16.dp),
            verticalAlignment = Alignment.CenterVertically,
        ) {
            icons.forEachIndexed { index, icon ->
                val offsetX = iconOffsets[index].first.value
                val offsetY = iconOffsets[index].second.value
                Box(
                    modifier = Modifier
                        .offset { IntOffset(offsetX.roundToInt(), offsetY.roundToInt()) }
                        .size(48.dp)
                        .background(if (index == highlightedIndex) Color.Red else Color.Gray, CircleShape)
                ) {
                    Icon(
                        imageVector = icon,
                        contentDescription = null,
                        modifier = Modifier.align(Alignment.Center).size(24.dp),
                        tint = Color.White
                    )
                }
            }
        }

        Spacer(modifier = Modifier.height(48.dp))

        DraggableIcon(
            icon = Icons.Default.Star,
            offsetX = draggableOffsetX.value,
            offsetY = draggableOffsetY.value,
            onDrag = { dragAmount ->
                coroutineScope.launch {
                    draggableOffsetX.snapTo(draggableOffsetX.value + dragAmount.x)
                    draggableOffsetY.snapTo(draggableOffsetY.value + dragAmount.y)
                    val overlapIndex = calculateOverlapIndex(Offset(draggableOffsetX.value, draggableOffsetY.value), icons.size)
                    highlightedIndex = overlapIndex
                }
            },
            onDragEnd = {
                coroutineScope.launch {
                    draggableOffsetX.animateTo(0f, tween(300))
                    draggableOffsetY.animateTo(0f, tween(300))
                    highlightedIndex = -1
                }
            }
        )
    }
}

@Composable
fun DraggableIcon(
    modifier: Modifier = Modifier,
    icon: ImageVector,
    offsetX: Float,
    offsetY: Float,
    onDrag: (Offset) -> Unit,
    onDragEnd: () -> Unit
) {
    Box(
        modifier = Modifier
            .offset { IntOffset(offsetX.roundToInt(), offsetY.roundToInt()) }
            .pointerInput(Unit) {
                detectDragGestures(
                    onDrag = { change, dragAmount ->
                        onDrag(Offset(dragAmount.x, dragAmount.y))
                    },
                    onDragEnd = {
                        onDragEnd()
                    }
                )
            }
            .size(48.dp)
            .background(Color.Blue, CircleShape)
    ) {
        Icon(
            imageVector = icon,
            contentDescription = null,
            modifier = Modifier.align(Alignment.Center).size(24.dp),
            tint = Color.White
        )
    }
}

fun calculateOverlapIndex(dragOffset: Offset, itemCount: Int): Int {
    val itemWidth = 48.dp.toPx() + 16.dp.toPx() // 아이템 너비와 간격을 포함
    val index = (dragOffset.x / itemWidth).toInt()
    return index.coerceIn(0, itemCount - 1)
}

fun Dp.toPx(): Float {
    return this.value * (160 / 160f) // 1dp = 1px for 160 dpi (baseline density)
}



-->
